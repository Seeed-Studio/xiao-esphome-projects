substitutions:
  name: "seeedstudio-iotbutton-v2"
  friendly_name: "Seeed Studio IoT Button V2"
  battery_multiplier: "3.0" 

esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  name_add_mac_suffix: true
  project:
    name: "seeedstudio.iot_button_v2"
    version: "1.1"
  platformio_options:
    board_upload.maximum_size: 4194304
  on_boot:
    priority: 600.0
    then:
      - light.turn_off: blue_led
      - light.turn_on: red_led
      - script.execute: measure_battery # Measure battery immediately on startup
      - lambda: |-
          auto cause = esp_sleep_get_wakeup_cause();
          if ((cause == ESP_SLEEP_WAKEUP_EXT0 || cause == ESP_SLEEP_WAKEUP_EXT1) && id(button_gpio).state) {
            id(press_start_ms) = millis();
            id(last_activity_time) = millis();
          }
      - switch.template.publish:
          id: virtual_toggle_1
          state: !lambda 'return id(virtual_toggle_1_state);'
      - switch.template.publish:
          id: virtual_toggle_2
          state: !lambda 'return id(virtual_toggle_2_state);'
      - switch.template.publish:
          id: virtual_toggle_3
          state: !lambda 'return id(virtual_toggle_3_state);'
      - globals.set:
          id: booting
          value: 'false'

esp32:
  board: esp32-c6-devkitc-1
  variant: esp32c6
  flash_size: 4MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_FREERTOS_UNICORE: y
      CONFIG_FREERTOS_HZ: '1000'
      CONFIG_PM_USE_RTC_TIMER_REF: y
      CONFIG_XTAL_FREQ_40: y
      CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ: '80000000'
      CONFIG_PM_DFS_INIT_AUTO: n
      CONFIG_FREERTOS_USE_TICKLESS_IDLE: y
      CONFIG_PM_ENABLE: y
      CONFIG_PM_SLP_IRAM_OPT: y
      CONFIG_PM_RTOS_IDLE_OPT: y
      CONFIG_ESP_WIFI_SLP_IRAM_OPT: y
      CONFIG_PM_POWER_DOWN_CPU_IN_LIGHT_SLEEP: y
      CONFIG_PM_PROFILING: y

# Enable logging
logger:
  hardware_uart: USB_SERIAL_JTAG
  level: DEBUG

# Enable Home Assistant API
api:

ota:
  - platform: esphome

wifi:
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "seeedstudio-iot-button"
    ap_timeout: 10s

  # WiFi network status events
  on_connect:
    then:
      - logger.log: "WiFi Connected!"
      - light.turn_off: red_led  # Turn off red LED
      - light.turn_on: blue_led  # Turn on blue LED
      - globals.set:
          id: sleep_timeout_ms
          value: '30000'
      - script.execute: measure_battery

  on_disconnect:
    then:
      - logger.log: "WiFi Disconnected!"
      - light.turn_off: blue_led
      - light.turn_on: red_led

captive_portal:

output:
  - platform: gpio
    pin: GPIO0
    id: battery_enable_pin
    inverted: False
  - platform: gpio
    pin: GPIO14
    id: red_led_pin
    inverted: True
  - platform: gpio
    pin: GPIO3
    id: blue_led_pin
    inverted: True
  - platform: gpio
    pin: GPIO18
    id: enable_pin

deep_sleep:
  id: deep_sleep_1
  wakeup_pin:
    number: GPIO2
    allow_other_uses: True
  wakeup_pin_mode: INVERT_WAKEUP

sensor:
  - platform: adc
    pin: GPIO1
    name: "Battery Voltage"
    id: battery_voltage
    update_interval: never 
    attenuation: 12db
    unit_of_measurement: "V"
    accuracy_decimals: 2
    filters:
      - multiply: ${battery_multiplier}
      - sliding_window_moving_average:
          window_size: 10
          send_every: 10
      - exponential_moving_average:
          alpha: 0.1
          send_every: 1

  - platform: template
    name: "Battery Percentage"
    id: battery_percentage
    update_interval: never
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:battery"
    device_class: "battery"
    lambda: |-
      float v = id(battery_voltage).state;
      if (isnan(v) || v < 2.75f) return {};

      // --- Lookup table algorithm: precise mapping of lithium battery discharge curve ---
      float pct;
      if (v >= 4.15f) pct = 100.0f;
      else if (v >= 4.0f) pct = 90.0f + (v - 4.0f) * 24.5f;
      else if (v >= 3.7f) pct = 20.0f + (v - 3.7f) * 143.5f;
      else if (v >= 3.5f) pct = 5.0f + (v - 3.5f) * 235.7f;
      else if (v >= 3.0f) pct = (v - 3.0f) * 12.3f;
      else pct = 0.0f;

      // --- Anti-jitter logic: ensure numerical stability ---
      if (pct > id(last_battery_percentage) && (pct - id(last_battery_percentage)) < 8.0f) {
        pct = id(last_battery_percentage);
      } else {
        id(last_battery_percentage) = pct;
      }
      return pct;

switch:
  - platform: output
    name: "LED Strip Power"
    output: enable_pin
    id: led_power
    restore_mode: ALWAYS_ON  # Auto-enable on startup
    internal: true

  # Virtual switches for button actions
  - platform: template
    name: "Switch 1"
    id: virtual_toggle_1
    optimistic: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return !id(booting);'
          then:
            - logger.log: "Single Short Clicked"
            - logger.log: "Switch 1 turned ON"
            - globals.set:
                id: virtual_toggle_1_state
                value: 'true'
            # Toggle blue LED to indicate button press
            - light.turn_on:
                id: rgb_led
                effect: "Blink"
            - delay: 1s
            - light.turn_off: rgb_led
            - globals.set:
                id: last_activity_time
                value: !lambda 'return millis();'
      # Add your switch-on action
    turn_off_action:
      - if:
          condition:
            lambda: 'return !id(booting);'
          then:
            - logger.log: "Single Short Clicked"
            - logger.log: "Switch 1 turned OFF"
            - globals.set:
                id: virtual_toggle_1_state
                value: 'false'
            # Toggle blue LED to indicate button press
            - light.turn_on:
                id: rgb_led
                effect: "Blink"
            - delay: 1s
            - light.turn_off: rgb_led
            - globals.set:
                id: last_activity_time
                value: !lambda 'return millis();'
      # Add your closing action

  - platform: template
    name: "Switch 2"
    id: virtual_toggle_2
    optimistic: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return !id(booting);'
          then:
            - logger.log: "Double Clicked"
            - logger.log: "Switch 2 turned ON"
            - globals.set:
                id: virtual_toggle_2_state
                value: 'true'
            # Double blink blue LED to indicate button press
            - light.turn_on:
                id: rgb_led
                brightness: 100%
                red: 100%
                green: 50%
                blue: 0%
                effect: "Subtle Flicker"
            - delay: 1s
            - light.turn_off: rgb_led
            - globals.set:
                id: last_activity_time
                value: !lambda 'return millis();'
      # Add your switch-on action
    turn_off_action:
      - if:
          condition:
            lambda: 'return !id(booting);'
          then:
            - logger.log: "Double Clicked"
            - logger.log: "Switch 2 turned OFF"
            - globals.set:
                id: virtual_toggle_2_state
                value: 'false'
            # Double blink blue LED to indicate button press
            - light.turn_on:
                id: rgb_led
                brightness: 100%
                red: 100%
                green: 50%
                blue: 0%
                effect: "Subtle Flicker"
            - delay: 1s
            - light.turn_off: rgb_led
            - globals.set:
                id: last_activity_time
                value: !lambda 'return millis();'
      # Add your closing action

  - platform: template
    name: "Switch 3"
    id: virtual_toggle_3
    optimistic: true
    turn_on_action:
      - if:
          condition:
            lambda: 'return !id(booting);'
          then:
            - logger.log: "Long Press"
            - logger.log: "Switch 3 turned ON"
            - globals.set:
                id: virtual_toggle_3_state
                value: 'true'
            # Long blue LED on to indicate button press
            - light.turn_on:
                id: rgb_led
                effect: "Rainbow"
            - delay: 1s
            - light.turn_off: rgb_led
            - globals.set:
                id: last_activity_time
                value: !lambda 'return millis();'
      # Add your switch-on action
    turn_off_action:
      - if:
          condition:
            lambda: 'return !id(booting);'
          then:
            - logger.log: "Long Press"
            - logger.log: "Switch 3 turned OFF"
            - globals.set:
                id: virtual_toggle_3_state
                value: 'false'
            # Long blue LED on to indicate button press
            - light.turn_on:
                id: rgb_led
                effect: "Rainbow"
            - delay: 1s
            - light.turn_off: rgb_led
            - globals.set:
                id: last_activity_time
                value: !lambda 'return millis();'
      # Add your closing action

light:
  - platform: binary
    name: "SeeedStudio IoT Button Blue LED"
    output: blue_led_pin
    id: blue_led
    internal: true
  - platform: binary
    name: "SeeedStudio IoT Button Red LED"
    output: red_led_pin
    id: red_led
    internal: true
  - platform: esp32_rmt_led_strip
    internal: true
    pin: GPIO19
    num_leds: 1
    restore_mode: RESTORE_AND_OFF
    chipset: WS2812
    rgb_order: GRB
    is_rgbw: False
    name: "RGB Status LED"
    id: rgb_led
    effects:
      - random:
          name: "Random Color"
          transition_length: 5s
          update_interval: 10s
      - addressable_rainbow:
          name: "Rainbow"
      - strobe:
          name: "Blink"
          colors:
            - state: True
              brightness: 100%
              red: 100%
              green: 0%
              blue: 50%
              duration: 500ms
            - state: False
              duration: 500ms
      - flicker:
          name: "Subtle Flicker"
          alpha: 95%
          intensity: 1.5%

binary_sensor:
  - platform: gpio
    id: button_gpio
    pin:
      number: GPIO2
      inverted: True
      mode:
        input: True
        pullup: True
      allow_other_uses: True  # Also used as the wakeup pin for light_sleep
    name: "SeeedStudio IoT Button"
    on_press:
      - globals.set:
          id: last_activity_time
          value: !lambda 'return millis();'
      - globals.set:
          id: press_start_ms
          value: !lambda 'return millis();'
      - script.stop: finalize_click
    on_release:
      - globals.set:
          id: last_activity_time
          value: !lambda 'return millis();'
      - if:
          condition:
            lambda: 'return (millis() - id(press_start_ms)) >= 1500;'
          then:
            - lambda: |-
                id(click_count) = 0;
            - script.stop: finalize_click
            - switch.toggle: virtual_toggle_3
          else:
            - lambda: |-
                if (id(click_count) < 2) id(click_count)++;
            - script.execute: finalize_click

globals:
  - id: last_activity_time
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: sleep_timeout_ms
    type: uint32_t
    restore_value: no
    initial_value: '120000'
  - id: press_start_ms
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: click_count
    type: uint8_t
    restore_value: no
    initial_value: '0'
  - id: booting
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: virtual_toggle_1_state
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: virtual_toggle_2_state
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: virtual_toggle_3_state
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: last_battery_percentage
    type: float
    restore_value: yes
    initial_value: '100.0'

# Measurement script: ensure gate control is enabled before measurement and disabled after
script:
  - id: measure_battery
    then:
      - output.turn_on: battery_enable_pin
      - delay: 50ms # Wait for hardware circuit to stabilize
      - repeat:
          count: 10
          then:
            - component.update: battery_voltage
            - delay: 5ms
      - component.update: battery_percentage
      - output.turn_off: battery_enable_pin

  - id: finalize_click
    mode: restart
    then:
      - delay: 700ms
      - if:
          condition:
            lambda: 'return id(click_count) == 1;'
          then:
            - switch.toggle: virtual_toggle_1
          else:
            - if:
                condition:
                  lambda: 'return id(click_count) >= 2;'
                then:
                  - switch.toggle: virtual_toggle_2
      - lambda: |-
          id(click_count) = 0;

interval:
  - interval: 10s
    then:
      - if:
          condition:
            lambda: 'return (millis() - id(last_activity_time)) >= id(sleep_timeout_ms);'
          then:
            - logger.log: "No activity for 2 minutes, entering deep sleep"
            - output.turn_off: battery_enable_pin
            - light.turn_off: blue_led
            - light.turn_off: red_led
            - light.turn_off: rgb_led
            - deep_sleep.enter:
                id: deep_sleep_1
